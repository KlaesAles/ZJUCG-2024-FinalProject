## 计算机图形学课程大项目

**项目选择**：以具身智能（机器人）为主题：实现一个三维场景建模与真实感绘制的小系统；具有场景编辑与执行两种模式。

**项目概况**：基本实现了一个三维场景建模与真实感绘制的小系统，具有场景编辑与执行两种模式；实现了小机器人动画播放，但由于时间原因未能实现“由状态机控制小机器人在场景中运动与交互”的目标。

---

#### 已实现要求：

##### 基本要求：

- **建模**：具有基本体素的建模表达能力
- **存储**：支持导入导出`.obj`和`.fbx`格式模型
- **编辑**：具有材质、纹理的显示与编辑能力
- **变换**：具有几何变换功能
- **光照**：实现了`PBR`光照明模型，并实现光源编辑
- **漫游**：能对建模后场景进行漫游
- **记录**：能够提供动画播放功能（骨骼动画），能够提供屏幕截取录制功能

##### 高级要求：

- 漫游时可实时碰撞检测
- 光照明模型细化：实现了`PBR`光照明模型和三种类型光源（方向光、点光源、聚光灯）的实时阴影
- 具有一定的对象表达能力：能够表达复杂模型
- 复杂材质效果：支持`PBR`材质和普通材质导入（基础色、金属度、粗糙度、法线、AO贴图）

##### 额外功能：

- 支持读取`.fbx`文件骨骼数据和动画数据，能够播放骨骼动画
- 支持编辑后场景的保存与导入导出（包含模型与光源数据）
- 提供基础后处理选项

---

**项目已知问题**：由于时间来不及故没有修复

- 部分材质无法正确导入
- 由聚光灯逻辑产生的场景细小黑线

------

#### 项目系统架构：

- **动画 Animation：**

  - Animation

    ```
    ### **功能概述**
    1. **管理骨骼动画数据：**
       - 包含多个骨骼动画通道 (`BoneChannel`) 和每个骨骼的关键帧数据。
       - 定义动画的名称、时长 (`duration`)、播放速度 (`ticksPerSecond`)。
    
    2. **存储骨骼动画通道 (`BoneChannel`)：**
       - 每个`BoneChannel`包含对应骨骼的名称及其关键帧序列。
    
    3. **评估动画：**
       - 根据给定时间点计算骨骼变换矩阵 (`glm::mat4`)。
       - 实现关键帧插值，计算在指定时间点每个骨骼的平移、旋转和缩放。
    
    ### **主要成员函数**
    - `addBoneChannel`：向动画添加一个骨骼动画通道。
    - `evaluate`：基于给定时间点和骨骼信息映射 (`BoneInfo`)，计算骨骼的局部变换矩阵。
    
    ### **协作关系**
    1. **依赖 `BoneInfo` 类：**
       - 通过骨骼信息映射 (`boneInfoMap`)，提供骨骼名称和层级结构信息，辅助生成变换矩阵。
       
    2. **与 `BoneChannel` 和 `BoneKeyframe` 协作：**
       - `Animation` 通过 `BoneChannel` 和 `BoneKeyframe` 存储每个骨骼的关键帧数据，并执行时间插值计算。
    
    3. **使用外部库：**
       - `glm`：用于矢量、四元数插值和矩阵运算（如平移、旋转、缩放的组合计算）。
    ```

  - Animator

    ```
    ### **功能概述**
    `Animator`类用于管理骨骼动画的播放与更新，负责将动画与3D模型相结合，并在每帧动态计算骨骼变换矩阵，将其上传到着色器。
    
    #### **主要职责**
    1. **管理动画：**
       - 存储多个动画 (`animations`)。
       - 通过名称切换和播放指定动画。
       - 控制动画的播放和停止。
    
    2. **时间更新：**
       - 根据时间增量 (`deltaTime`)，更新动画时间。
       - 支持循环播放功能。
    
    3. **骨骼变换计算：**
       - 基于当前时间点，通过`Animation`类评估每个骨骼的局部变换。
       - 递归计算骨骼的全局变换矩阵，考虑父子骨骼关系。
    
    4. **上传骨骼矩阵到着色器：**
       - 将计算出的最终骨骼矩阵上传到GPU，供着色器使用。
    
    ---
    
    ### **主要成员函数**
    - `addAnimation`：添加动画到动画管理器。
    - `playAnimation`：指定并播放某个动画。
    - `stopAnimation`：停止当前播放的动画。
    - `update`：在每帧调用，更新动画状态并计算骨骼变换矩阵。
    - `computeGlobalTransform`：递归计算骨骼的全局变换矩阵。
    - `uploadBoneMatrices`：将骨骼变换矩阵上传到着色器。
    
    ---
    
    ### **协作关系**
    1. **与 `Animation` 类的协作：**
       - `Animator`通过`Animation`类存储和评估骨骼动画数据。
       - 使用`Animation::evaluate`获取当前时间点的局部骨骼变换。
    
    2. **与 `Model` 类的协作：**
       - `Animator`依赖`Model`类提供骨骼层次结构 (`boneParentMap`)、骨骼映射 (`boneMapping`) 和骨骼信息 (`boneInfoMap`)。
       - 使用模型的`offsetMatrix`计算最终变换矩阵。
    
    3. **与 OpenGL 的协作：**
       - 使用 OpenGL 函数（如`glUniformMatrix4fv`）将计算出的骨骼矩阵上传到 GPU。
       - 依赖模型着色器 (`shaderProgramID`) 实现骨骼动画在渲染中的应用。
    
    4. **使用外部库：**
       - **`glm`**：用于矩阵计算（如局部变换、全局变换、偏移矩阵等）。
       - **`std::map` 和 `std::vector`**：管理骨骼和动画数据。
    
    ---
    
    ### **类在系统设计中的作用**
    - **骨骼动画的核心管理模块：** 负责连接动画数据与模型渲染，为骨骼动画系统提供基础框架。
    - **实时动画驱动：** 提供时间驱动的动画播放逻辑，支持复杂的骨骼变换和着色器上传。
    
    ```

- **模型 Model：**

  - mesh

    ```
    ### **功能概述**
    `Mesh`类用于管理3D模型的网格数据，包括顶点、索引、材质和纹理信息，并通过OpenGL绘制网格对象。它支持PBR（基于物理的渲染）材质，能够结合动画和骨骼变形实现复杂的渲染效果。
    
    #### **主要职责**
    1. **存储网格数据：**
       - 管理顶点数组（位置、法线、切线、纹理坐标等）。
       - 存储骨骼动画相关信息（骨骼ID和权重）。
       - 管理索引数组和纹理数据。
    
    2. **支持PBR材质：**
       - 提供PBR材质参数（如金属度、粗糙度、AO等）。
       - 支持绑定多种PBR纹理（如反照率、法线、金属度等）。
    
    3. **与OpenGL交互：**
       - 通过顶点缓冲对象（VBO）和元素缓冲对象（EBO）管理网格数据。
       - 设置顶点属性指针以绑定顶点数据到GPU。
       - 将材质和纹理上传到着色器，完成渲染。
    
    4. **渲染功能：**
       - 提供`Draw`方法，实现网格的具体渲染过程。
       - 自动处理PBR材质和纹理的绑定。
    
    ---
    
    ### **主要成员函数**
    - **`Draw`**：通过着色器渲染网格，绑定PBR材质和纹理。
    - **`setupMesh`**：初始化OpenGL所需的缓冲区对象（VAO、VBO、EBO）并配置顶点属性指针。
    - **`setupPBRMaterial`**：根据纹理类型自动配置PBR材质参数和纹理。
    
    ---
    
    ### **协作关系**
    1. **与`PBRMaterial`类的协作：**
       - `Mesh`类使用`PBRMaterial`存储材质参数和纹理信息。
       - 自动根据纹理类型设置`PBRMaterial`的对应纹理ID和使用标志。
    
    2. **与`Shader`类的协作：**
       - 在`Draw`方法中使用`Shader`类设置材质参数（如反照率、金属度等）。
       - 上传材质和纹理数据到着色器。
    
    3. **与OpenGL的协作：**
       - 使用VAO、VBO、EBO管理网格数据。
       - 调用OpenGL函数（如`glDrawElements`、`glActiveTexture`）完成渲染。
    
    4. **与骨骼动画系统的协作：**
       - 通过`boneIDs`和`weights`支持骨骼动画数据。
       - 与骨骼变换矩阵结合实现动画网格的动态变形。
    
    5. **与外部资源的协作：**
       - 使用纹理（`Texture`结构）加载外部图片数据，实现复杂的材质效果。
    
    ---
    
    ### **类在系统设计中的作用**
    - **网格渲染核心模块：**
      - `Mesh`类是模型系统的基础单位，负责存储和管理单个网格的所有数据及其渲染逻辑。
    - **PBR渲染支持：**
      - 提供PBR材质和纹理支持，为高质量渲染提供基础。
    - **动画支持：**
      - 通过骨骼ID和权重与动画系统协作，支持动态网格变形。
    ```

  - Model

    ```
    ### **功能概述**
    `Model`类是3D模型的核心管理组件，负责从外部文件加载模型数据、解析网格、纹理和骨骼动画，并提供接口将模型数据渲染到屏幕上。
    
    #### **主要职责**
    1. **加载模型数据：**
       - 通过`Assimp`库解析3D模型文件，支持多种格式（如FBX、OBJ等）。
       - 提取网格、材质、纹理、骨骼和动画数据。
    
    2. **骨骼动画支持：**
       - 解析骨骼层次结构（`readHierarchy`），记录父子关系。
       - 解析动画数据并生成骨骼动画通道和关键帧。
       - 绑定骨骼影响到对应顶点数据。
    
    3. **材质和纹理管理：**
       - 加载和缓存纹理，支持多种PBR纹理类型（如反照率、法线、金属度等）。
       - 自动处理重复纹理加载以优化性能。
    
    4. **渲染支持：**
       - 提供`Draw`方法，调用所有网格的绘制函数。
       - 结合动画数据和骨骼变换，实现动态渲染。
    
    ---
    
    ### **主要成员函数**
    - **`loadModel`**：解析3D模型文件，提取网格、材质、骨骼和动画数据。
    - **`processNode`**：递归处理模型节点，提取子网格和子节点。
    - **`processMesh`**：解析ASSIMP的网格数据，生成自定义`Mesh`对象。
    - **`loadMaterialTextures`**：加载指定类型的纹理，支持纹理去重。
    - **`readHierarchy`**：递归解析骨骼层次关系，记录父子关系。
    - **`addBoneData`**：将骨骼影响绑定到顶点，支持多骨骼影响。
    - **`printBoneHierarchy`**：输出骨骼的父子层次结构，便于调试。
    
    ---
    
    ### **协作关系**
    1. **与`Assimp`库协作：**
       - 使用`Assimp`读取模型文件并解析其网格、材质和动画数据。
       - 通过`aiScene`结构存储完整的模型数据，递归解析节点和网格。
    
    2. **与`Mesh`类协作：**
       - 将解析后的网格数据转换为`Mesh`对象，统一管理。
       - 调用`Mesh::Draw`方法渲染每个网格。
    
    3. **与`PBRMaterial`协作：**
       - 通过`Mesh`类中的`PBRMaterial`存储材质属性和PBR纹理。
    
    4. **与动画系统协作：**
       - 解析动画数据生成`Animation`和`BoneChannel`。
       - 记录骨骼与顶点的绑定关系，支持骨骼变形。
    
    5. **与OpenGL协作：**
       - 加载纹理数据到GPU。
       - 调用`Mesh`类实现网格的绘制。
    
    6. **与外部资源协作：**
       - 支持从外部文件加载模型（如`.obj`、`.fbx`）。
       - 支持STB库加载纹理图片。
    
    ---
    
    ### **类在系统设计中的作用**
    1. **模型管理中心：**
       - 将模型加载、解析、存储和渲染的逻辑集中在一个模块中。
       - 提供统一的接口供其他系统调用。
    
    2. **骨骼动画核心：**
       - 支持动态动画，通过骨骼层次结构和关键帧实现模型变形。
       - 为动画播放系统提供必要的数据支持。
    
    3. **渲染和材质管理：**
       - 集成PBR材质与多种纹理类型，为高质量渲染提供支持。
    ```

  - PBRMaterial

    ```
    ### **功能概述**
    `PBRMaterial`结构用于存储和管理PBR（基于物理的渲染）材质的参数和纹理，支持高质量的渲染效果，通过与着色器协作实现真实的物理材质表现。
    
    #### **主要职责**
    1. **存储PBR材质属性：**
       - 包括基础颜色（`albedo`）、金属度（`metallic`）、粗糙度（`roughness`）和环境光遮蔽（`ao`）等材质参数。
       - 允许默认使用常量值或绑定纹理图。
    
    2. **存储PBR纹理：**
       - 支持多种PBR纹理（如`albedoMap`、`metallicMap`、`roughnessMap`等）。
       - 纹理ID与OpenGL纹理对象绑定，用于在渲染时上传至GPU。
    
    3. **纹理使用标志管理：**
       - 提供`updateUsageFlags`方法，根据纹理ID更新是否启用特定纹理的标志（`useAlbedoMap`等）。
       - 确保渲染时能够正确判断是否使用纹理覆盖参数。
    
    ---
    
    ### **主要成员**
    - **材质参数：**
      - `albedo`：基础颜色，默认为白色`(1.0, 1.0, 1.0)`。
      - `metallic`：金属度，默认为0（非金属）。
      - `roughness`：粗糙度，默认为0.5。
      - `ao`：环境光遮蔽强度，默认为1。
    
    - **纹理资源：**
      - `albedoMap`：基础颜色纹理。
      - `metallicMap`：金属度纹理。
      - `roughnessMap`：粗糙度纹理。
      - `normalMap`：法线纹理。
      - `aoMap`：环境光遮蔽纹理。
    
    - **纹理使用标志：**
      - `useAlbedoMap`、`useMetallicMap`等布尔值，表示是否启用了对应纹理。
    
    ---
    
    ### **协作关系**
    1. **与`Mesh`类的协作：**
       - `PBRMaterial`作为`Mesh`类的一部分，存储单个网格的材质信息。
       - 在`Mesh::Draw`中，根据`PBRMaterial`中的属性和纹理，设置着色器的材质参数。
    
    2. **与渲染系统的协作：**
       - 在渲染过程中，`PBRMaterial`的参数和纹理绑定至着色器，控制材质表现。
       - 在着色器中启用或禁用纹理，根据`use*Map`标志决定是否使用特定纹理。
    
    3. **与OpenGL的协作：**
       - 使用纹理ID绑定纹理对象到GPU。
       - 根据`updateUsageFlags`动态更新纹理状态，避免无效纹理绑定。
    
    4. **与外部资源协作：**
       - 从模型文件或外部纹理文件加载PBR材质参数和纹理。
       - 在`Model`或`Mesh`类中调用`updateUsageFlags`以确保材质配置正确。
    
    ---
    
    ### **类在系统设计中的作用**
    1. **物理材质的核心模块：**
       - 提供PBR参数和纹理支持，为高质量的物理渲染奠定基础。
    
    2. **渲染优化：**
       - 动态判断是否使用纹理，避免不必要的着色器调用和资源绑定。
    
    3. **材质与纹理管理：**
       - 将材质参数与纹理绑定统一存储，简化了渲染时的材质处理逻辑。
    ```

    

  - BoundingBox

    ```
    ### **功能概述**
    `BoundingBox`类用于表示三维空间中的轴对齐包围盒（AABB, Axis-Aligned Bounding Box），主要用于3D模型的空间计算和优化，例如碰撞检测、视锥裁剪以及模型包围范围计算。
    
    #### **主要职责**
    1. **定义和初始化包围盒：**
       - 使用初始值`min=FLT_MAX`和`max=-FLT_MAX`初始化包围盒。
       - 可通过点集初始化包围盒。
    
    2. **动态更新包围盒：**
       - 根据新的点调整包围盒的最小点和最大点。
    
    3. **提供空间属性计算：**
       - 获取包围盒的中心点。
       - 计算包围盒的尺寸（宽、高、深）。
    
    4. **空间关系判断：**
       - 判断一个点是否在包围盒内。
       - 检查两个包围盒是否相交。
    
    5. **合并包围盒：**
       - 合并当前包围盒与另一个包围盒，生成包含两者的最小包围盒。
    
    ---
    
    ### **主要成员函数**
    - **`update`**：更新包围盒的最小点和最大点。
    - **`getCenter`**：返回包围盒的中心点。
    - **`getSize`**：返回包围盒的尺寸。
    - **`contains`**：判断一个点是否在包围盒内。
    - **`intersects`**：判断两个包围盒是否相交。
    - **`merge`**：合并两个包围盒，扩展当前包围盒。
    
    ---
    
    ### **协作关系**
    1. **与模型/网格数据的协作：**
       - 包围盒通过模型或网格的顶点集合初始化和更新。
       - 在`Model`类中，用于计算每个网格的包围范围。
    
    2. **与渲染系统的协作：**
       - 用于视锥裁剪，确定模型是否在视野范围内，从而优化渲染。
       - 在层次化场景中（如八叉树或BVH），用包围盒快速判断空间分布。
    
    3. **与物理系统的协作：**
       - 用于简单的碰撞检测和相交测试。
       - 提供物理引擎中的快速空间关系计算。
    
    4. **与`glm`库的协作：**
       - 使用`glm::min`和`glm::max`进行向量运算。
       - 便于与其他模块（如`Vertex`或`Transform`）共享通用的线性代数工具。
    
    ---
    
    ### **类在系统设计中的作用**
    1. **空间管理的基本工具：**
       - 定义3D空间内的最小包围范围，为场景管理和优化提供基础。
       
    2. **碰撞检测的辅助模块：**
       - 快速判断点、包围盒之间的空间关系，用于物理引擎和交互逻辑。
    
    3. **性能优化：**
       - 减少不必要的计算，如视锥裁剪、包围盒合并等，通过空间判断优化渲染或物理计算。
    ```

  - BoneInfo

    ```
    ### **功能概述**
    `BoneInfo`结构体是骨骼动画系统的核心数据结构之一，负责存储每个骨骼的关键信息，用于实现骨骼动画中的变换和动画驱动。
    
    #### **主要职责**
    1. **存储骨骼偏移矩阵 (`offsetMatrix`)：**
       - `offsetMatrix`用于将顶点从模型空间转换到骨骼空间。
       - 每个骨骼有一个唯一的偏移矩阵，它是骨骼绑定位置的逆变换。
    
    2. **存储最终变换矩阵 (`finalTransform`)：**
       - `finalTransform`结合动画变换矩阵和父骨骼的全局变换，用于将顶点从骨骼空间转换回模型空间。
       - 动态更新，每帧计算以实现骨骼动画。
    
    ---
    
    ### **协作关系**
    1. **与动画系统的协作：**
       - 在动画播放过程中，`Animator`类通过递归计算骨骼的全局变换，更新`finalTransform`。
       - `Animation`类通过骨骼通道数据（`BoneChannel`）驱动动画变换。
    
    2. **与`Model`类的协作：**
       - `Model`解析骨骼数据时，将每个骨骼的偏移矩阵存储到`BoneInfo`。
       - `Model`类提供骨骼层次结构，辅助骨骼动画的全局变换计算。
    
    3. **与渲染系统的协作：**
       - `finalTransform`用于构建骨骼动画的最终顶点位置。
       - 在`Animator`中统一上传到GPU的骨骼矩阵数组，用于在着色器中实现骨骼动画的顶点变形。
    
    4. **与`glm`库的协作：**
       - 使用`glm::mat4`进行矩阵计算（如变换、插值等）。
       - 便于与其他模块（如`Mesh`或`Animation`）共享通用的线性代数工具。
    
    ---
    
    ### **类在系统设计中的作用**
    1. **骨骼动画的基础数据结构：**
       - 提供骨骼空间和模型空间的关键转换矩阵。
       - 存储骨骼的最终变换结果，用于动画驱动渲染。
    
    2. **高效动画计算：**
       - 支持每帧动态更新的动画系统，确保骨骼动画变换实时生效。
       - 通过偏移矩阵减少骨骼动画的计算复杂度。
    ```

- **渲染 Render：**

  - **注**：由于时间关系，没有对Render类进行重构，GUI等逻辑都集成在Render类中

  - Renderer

    ```
    ### **功能概述**
    `Renderer`类是整个渲染系统的核心组件，负责管理3D场景的渲染循环、光照计算、阴影生成、后处理效果和用户界面的集成。
    
    #### **主要职责**
    1. **渲染流程管理：**
       - 管理主渲染循环。
       - 处理输入事件、更新场景和渲染每一帧。
    
    2. **光照与阴影管理：**
       - 动态更新光源数据和阴影贴图。
       - 支持多种光照类型（定向光、点光源、聚光灯）的计算。
    
    3. **后处理与特效支持：**
       - 集成后处理管线，支持各种屏幕后处理效果（如灰度、色差等）。
    
    4. **用户界面集成：**
       - 使用`ImGui`提供用户交互界面，支持材质编辑、光照管理、模型加载等功能。
    
    5. **资源管理与工具支持：**
       - 提供场景保存与加载功能。
       - 支持模型导出为`.obj`格式文件。
       - 管理天空盒加载与切换。
    
    6. **调试与开发辅助：**
       - 支持包围球渲染。
       - 提供实时光照与材质调试视图。
    
    ---
    
    ### **主要成员函数**
    - **初始化与清理：**
      - `initialize`：初始化渲染器和所需资源。
      - `cleanup`：清理资源，包括`ImGui`和OpenGL资源。
    
    - **渲染管理：**
      - `run`：主渲染循环，处理输入、更新场景和渲染。
      - `renderFrame`：渲染一帧，包括光照计算、后处理和用户界面。
    
    - **光照与阴影：**
      - `updateShadowMaps`：动态更新阴影贴图。
      - `drawBoundingSphere`：绘制物体的包围球，用于调试。
    
    - **场景与资源管理：**
      - `saveScene`/`loadScene`：保存和加载场景至JSON文件。
      - `getSceneFiles`：列出可用的场景文件。
      - `exportToObj`：导出选定物体为`.obj`文件。
    
    - **用户输入与交互：**
      - `processInput`：处理用户输入，包括相机移动、截图、录屏等。
      - `screenToWorldRay`：将屏幕坐标转换为世界射线，用于物体拾取。
      - `pickObject`：射线拾取物体，返回最接近的物体。
    
    - **天空盒管理：**
      - `loadSkybox`/`loadSkyboxFromPanorama`：加载天空盒或全景图。
      - `getSkyboxList`/`getPanoramaList`：列出可用的天空盒或全景图文件。
    
    ---
    
    ### **协作关系**
    1. **与场景相关类的协作：**
       - **`Scene`**：管理所有`GameObject`，由`Renderer`负责调用其更新和渲染方法。
       - **`GameObject`**：提供物体的模型和变换信息，用于渲染和用户交互。
       - **`Model`**：管理模型的网格数据、材质和动画。
    
    2. **与光照与阴影系统的协作：**
       - **`LightManager`**：管理场景中的所有光源数据。
       - **`ShadowManager`**：生成和更新阴影贴图，并与光源数据同步。
    
    3. **与后处理系统的协作：**
       - **`PostProcessing`**：管理屏幕后处理效果，动态更新特效参数并渲染。
    
    4. **与用户界面系统的协作：**
       - **`ImGui`**：提供用户交互界面，用于修改材质参数、加载模型、控制光源等。
    
    5. **与OpenGL资源的协作：**
       - 通过`Shader`类管理着色器，设置渲染参数。
       - 使用`Mesh`类提供网格数据，实现物体和包围球的渲染。
    
    6. **与资源文件的协作：**
       - **场景文件**：支持`.json`格式的场景保存与加载。
       - **模型文件**：支持加载`.obj`和`.fbx`格式模型。
       - **纹理文件**：支持天空盒和全景图的纹理加载。
    
    ---
    
    ### **类在系统设计中的作用**
    1. **渲染核心模块：**
       - 负责连接所有子系统（场景、光照、阴影、后处理等），构成完整的渲染流程。
    
    2. **用户交互中心：**
       - 提供用户界面，方便开发人员和用户修改场景内容、测试特效等。
    
    3. **性能优化与调试支持：**
       - 动态调整光照和阴影设置，提高渲染性能。
       - 提供调试视图和包围球渲染，便于开发阶段的问题定位。
    ```

  - PostProcessing

    ```
    ### **功能概述**
    `PostProcessing`类是一个用于屏幕后处理的模块，支持通过多次渲染通道（Pass）实现各种后处理效果，例如灰度化、色差、暗角等。它通过帧缓冲对象（Framebuffer Object, FBO）和着色器组合，实现高效的屏幕后处理管线。
    
    #### **主要职责**
    1. **初始化与资源管理：**
       - 创建主渲染帧缓冲（`fbo`）和中间帧缓冲（`intermediateFBO`）。
       - 初始化后处理所需的纹理、渲染缓冲对象（RBO）以及屏幕四边形（Quad）。
    
    2. **注册和管理后处理效果：**
       - 允许注册多个后处理效果，每个效果绑定一个着色器程序和可选的配置函数。
       - 提供接口启用或禁用特定效果，以及动态更新效果参数。
    
    3. **处理后处理流程：**
       - 支持多次渲染通道，每个通道应用一个后处理效果。
       - 支持将结果从主帧缓冲传递到中间帧缓冲，最后输出到屏幕。
    
    4. **渲染到屏幕：**
       - 合并所有启用的后处理效果，并输出最终结果到默认帧缓冲（屏幕）。
    
    ---
    
    ### **主要成员函数**
    1. **初始化与清理：**
       - `initialize`：创建和配置帧缓冲、纹理及屏幕四边形。
       - `~PostProcessing`：释放帧缓冲、纹理和VAO/VBO等OpenGL资源。
    
    2. **效果注册与配置：**
       - `registerEffect`：注册新的后处理效果。
       - `enableEffect`/`isEffectEnabled`：启用或禁用特定效果。
       - `setEffectConfig`：动态设置效果的配置参数。
    
    3. **渲染管线管理：**
       - `begin`：绑定主帧缓冲，开始捕获场景渲染。
       - `endAndRender`：将主帧缓冲的内容应用后处理效果，并输出到屏幕或下一个帧缓冲。
    
    4. **工具函数：**
       - `hasEnabledEffects`：检查是否启用了任何后处理效果。
       - `initQuad`：初始化屏幕四边形，用于渲染帧缓冲内容。
    
    ---
    
    ### **协作关系**
    1. **与`Shader`类的协作：**
       - 每个后处理效果依赖一个`Shader`对象定义其具体的处理逻辑。
       - 通过配置函数为`Shader`动态设置参数（如色差强度、暗角半径等）。
    
    2. **与OpenGL的协作：**
       - 使用帧缓冲对象（`fbo`和`intermediateFBO`）捕获渲染内容。
       - 利用屏幕四边形和纹理，将后处理效果应用到整个场景。
    
    3. **与`Renderer`类的协作：**
       - 作为渲染器的一部分，用于实现最终屏幕输出。
       - `Renderer`调用`begin`和`endAndRender`管理后处理流程。
    
    4. **与用户界面的协作：**
       - 提供接口动态启用、禁用和配置后处理效果。
       - 用户通过`ImGui`等界面调整效果参数，实时更新渲染结果。
    
    ---
    
    ### **类在系统设计中的作用**
    1. **模块化后处理管线：**
       - 提供灵活的后处理效果管理接口，支持添加、启用、禁用和配置多个效果。
       - 支持多通道渲染，满足复杂的后处理需求。
    
    2. **渲染优化：**
       - 使用中间帧缓冲减少资源重复分配。
       - 仅在启用效果时执行相关的渲染逻辑，提高性能。
    
    3. **易用性与扩展性：**
       - 提供直观的接口（如`registerEffect`、`enableEffect`），便于添加新效果。
       - 支持用户动态调整效果参数，提升开发效率和交互体验。
    ```

- **场景 Scene：**

  - Camera

    ```
    ### **功能概述**
    `Camera`类是一个实现自由移动视角的相机系统，支持第一人称和第三人称视角的移动与旋转。通过与`Scene`和`CollisionManager`协作，它能够处理场景中的碰撞检测，同时提供视图和投影矩阵供渲染器使用。
    
    #### **主要职责**
    1. **相机运动：**
       - 支持通过键盘输入实现自由移动（前进、后退、左右平移、上下移动）。
       - 支持通过鼠标输入调整相机方向（偏航和俯仰）。
    
    2. **相机视图与投影：**
       - 提供视图矩阵（`GetViewMatrix`）用于场景渲染。
       - 提供投影矩阵（`GetProjectionMatrix`）支持可调视野角度的透视投影。
    
    3. **碰撞检测：**
       - 在移动过程中与场景的物体进行碰撞检测，防止穿模或不合法的位置更新。
    
    4. **相机配置：**
       - 支持动态调整运动速度、鼠标灵敏度和视野角度。
    
    ---
    
    ### **主要成员函数**
    1. **输入处理：**
       - `ProcessKeyboard`：根据方向和时间步长更新相机位置，并进行碰撞检测。
       - `ProcessMouseMovement`：根据鼠标输入调整相机偏航和俯仰角。
       - `ProcessMouseScroll`：动态调整相机的视野角度（Zoom）。
    
    2. **矩阵获取：**
       - `GetViewMatrix`：获取当前相机的视图矩阵，用于OpenGL渲染。
       - `GetProjectionMatrix`：获取基于Zoom的透视投影矩阵。
    
    3. **碰撞检测与包围盒：**
       - `updateBoundingBox`：根据相机位置更新包围盒。
       - 通过`CollisionManager::detectCollisions`检查包围盒与场景中物体的碰撞。
    
    4. **内部更新：**
       - `updateCameraVectors`：根据偏航和俯仰角更新相机的方向向量（`Front`、`Up`、`Right`）。
    
    ---
    
    ### **协作关系**
    1. **与`Scene`类的协作：**
       - **作用**：访问场景中的物体列表，用于碰撞检测。
       - **交互**：调用`scene.getGameObjects()`获取所有场景物体的包围盒信息。
    
    2. **与`CollisionManager`类的协作：**
       - **作用**：检测相机的包围盒与场景物体的碰撞。
       - **交互**：调用`CollisionManager::detectCollisions`检查当前位置是否合法。
    
    3. **与渲染器的协作：**
       - **作用**：提供相机视图和投影矩阵，用于场景渲染。
       - **交互**：渲染器调用`GetViewMatrix`和`GetProjectionMatrix`计算最终的MVP矩阵。
    
    4. **与用户输入系统的协作：**
       - **作用**：通过键盘和鼠标输入控制相机移动和方向。
       - **交互**：在`Renderer`中捕获输入事件并调用相应的`Camera`方法。
    
    ---
    
    ### **类在系统设计中的作用**
    1. **视角控制核心：**
       - 负责动态调整视角和视野，为用户提供沉浸式的场景交互体验。
    
    2. **场景交互中枢：**
       - 与场景物体的包围盒交互，确保相机行为符合物理逻辑（例如避免穿墙）。
    
    3. **渲染参数提供者：**
       - 提供实时更新的视图和投影矩阵，确保场景渲染符合当前视角。
    ```

  - GameObject

    ```
    ### **功能概述**
    `GameObject`类是场景中的核心实体，用于表示单个对象，包括其模型数据、变换信息、动画系统和交互状态。
    
    #### **主要职责**
    1. **变换管理：**
       - 管理物体的**位置**、**缩放**和**旋转**。
       - 通过计算模型矩阵`modelMatrix`将变换信息传递给渲染器。
    
    2. **模型管理：**
       - 使用`Model`类加载和存储模型数据（包括网格、纹理和动画）。
       - 管理物体的包围盒以支持碰撞检测和选中检测。
    
    3. **动画支持：**
       - 通过`Animator`类管理模型动画。
       - 支持播放、停止和动态切换动画。
    
    4. **渲染属性：**
       - 支持访问并修改模型的PBR材质参数。
       - 提供骨骼动画的相关Uniform信息给着色器。
    
    5. **交互状态：**
       - 提供选中状态标志`isSelected`，支持物体在场景中的选中与交互操作。
    
    ---
    
    ### **主要成员函数**
    1. **变换相关：**
       - `setPosition`、`setScale`、`setRotation`：动态调整物体的变换属性。
       - `getPosition`、`getScale`、`getRotation`：获取变换属性。
       - `updateModelMatrix`：更新物体的模型矩阵，并同步包围盒信息。
       - `updateBoundingBox`：根据模型的包围盒和当前变换计算新的全局包围盒。
    
    2. **动画控制：**
       - `addAnimation`：向物体添加新动画。
       - `playAnimation`、`stopAnimation`：播放或停止特定的动画。
       - `update`：更新动画逻辑。
    
    3. **渲染支持：**
       - `getPBRMaterial`：获取物体中某个网格的PBR材质。
       - `uploadBoneUniforms`：上传骨骼动画相关的Uniform数据到着色器。
    
    4. **状态管理：**
       - `getIsSelected`、`setIsSelected`：获取或设置物体的选中状态。
    
    ---
    
    ### **协作关系**
    1. **与`Model`类的协作：**
       - **作用**：加载物体的模型数据，包括网格、纹理、包围盒和动画。
       - **交互**：
         - 使用`Model`类加载模型文件（如OBJ、FBX）。
         - 获取模型的动画数据并传递给`Animator`。
    
    2. **与`Animator`类的协作：**
       - **作用**：控制模型的骨骼动画。
       - **交互**：
         - 在构造函数中从`Model`中加载动画数据到`Animator`。
         - 调用`Animator`更新动画状态并传递骨骼矩阵到着色器。
    
    3. **与渲染器的协作：**
       - **作用**：提供物体的模型矩阵、PBR材质和骨骼动画信息用于渲染。
       - **交互**：
         - 渲染器调用`getModelMatrix`获取物体的模型矩阵。
         - 调用`uploadBoneUniforms`上传动画相关的数据。
    
    4. **与`BoundingBox`类的协作：**
       - **作用**：计算和更新物体的全局包围盒，用于碰撞检测和选中操作。
       - **交互**：
         - 在`updateBoundingBox`中，结合模型的局部包围盒和物体的变换计算全局包围盒。
    
    5. **与用户输入系统的协作：**
       - **作用**：通过`isSelected`支持物体的选中和拖拽操作。
    
    ---
    
    ### **类在系统设计中的作用**
    1. **场景核心单元：**
       - 作为`Scene`类中存储的基础单元，每个`GameObject`代表一个具体的渲染实体。
    
    2. **动画控制器：**
       - 管理复杂的骨骼动画，动态更新物体的骨骼变换矩阵。
    
    3. **交互支持：**
       - 通过包围盒和选中状态支持用户交互，如拾取、拖动等。
    
    4. **渲染数据提供者：**
       - 提供变换矩阵、材质属性和骨骼动画信息供渲染器使用。
    ```

  - Scene

    ```
    #### **功能概述**
    `Scene`类是3D渲染系统的核心管理模块，主要负责管理场景中的物体（`GameObject`）和光源（通过`LightManager`），包括添加、更新、渲染以及数据的序列化和反序列化。
    
    ---
    
    ### **主要职责**
    1. **场景管理：**
       - 管理场景中的所有`GameObject`，提供添加、获取功能。
       - 通过`LightManager`管理所有光源。
    
    2. **逻辑更新：**
       - 逐帧更新所有物体的逻辑（如动画更新）。
    
    3. **渲染控制：**
       - 渲染场景中的所有物体。
       - 支持常规渲染和阴影贴图渲染。
    
    4. **数据持久化：**
       - 提供场景的序列化和反序列化功能，用于保存和加载场景数据。
    
    ---
    
    ### **主要成员函数**
    
    #### **场景管理**
    1. `void addGameObject(const std::shared_ptr<GameObject>& obj)`
       - 向场景中添加一个物体。
    
    2. `std::vector<std::shared_ptr<GameObject>>& getGameObjects()`
       - 返回当前场景中所有的物体引用。
    
    #### **逻辑更新**
    - `void update(float deltaTime, Shader& shader)`
      - 调用每个物体的`update`函数，更新其逻辑（如动画状态）。
    
    #### **渲染**
    1. `void draw(Shader& shader) const`
       - 渲染所有物体。
    
    2. `void draw(Shader& shader, const std::shared_ptr<GameObject>& selectedObject) const`
       - 渲染所有物体，同时为选中的物体添加高亮效果。
    
    3. `void drawShadowMaps(Shader& shadowShader)`
       - 通过阴影着色器渲染场景物体的阴影贴图。
    
    #### **序列化与反序列化**
    1. `nlohmann::json serialize()`
       - 将场景数据（包括物体和光源）序列化为JSON格式，便于保存。
    
    2. `void deserialize(const nlohmann::json& sceneJson)`
       - 从JSON数据中加载场景，包括物体和光源。
    
    ---
    
    ### **协作关系**
    
    1. **与`GameObject`的协作：**
       - 通过`std::shared_ptr`管理场景中的物体。
       - 调用物体的`update`方法更新逻辑。
       - 调用物体的`draw`方法进行渲染。
    
    2. **与`LightManager`的协作：**
       - 管理光源的添加、删除和序列化。
       - 在渲染和阴影生成中与光源系统紧密配合。
    
    3. **与`Shader`的协作：**
       - 通过着色器完成场景的渲染，包括常规渲染和阴影贴图。
    
    4. **与JSON库的协作：**
       - 使用`nlohmann::json`库完成场景数据的序列化与反序列化。
    
    ---
    
    ### **类在系统设计中的作用**
    
    1. **核心管理模块：**
       - 作为场景中物体和光源的唯一管理者，提供统一的接口处理场景数据。
    
    2. **逻辑与渲染的桥梁：**
       - 负责将每帧的逻辑更新和渲染调用统一起来，确保场景的一致性。
    
    3. **数据持久化：**
       - 通过序列化与反序列化功能，支持场景的保存与加载，方便编辑器和用户操作。
    
    4. **扩展性：**
       - 可以通过扩展`GameObject`和`LightManager`的功能，为场景增加更多复杂的逻辑和效果。
    ```

  - Skybox

    ```
    ### **功能概述**
    `Skybox`类用于在3D场景中渲染天空盒，通过立方体贴图或全景图模拟背景环境。它支持两种纹理来源：六面贴图（CubeMap）和全景图（Panorama）。
    
    ---
    
    ### **主要职责**
    1. **加载天空盒纹理：**
       - 从六张面贴图（CubeMap）或一张全景图（Panorama）生成立方体贴图。
       - 提供错误处理机制，确保纹理加载的健壮性。
    
    2. **配置 OpenGL 缓存：**
       - 初始化顶点缓冲对象（VBO）和顶点数组对象（VAO）。
       - 配置立方体贴图的纹理过滤和环绕模式。
    
    3. **渲染天空盒：**
       - 渲染一个立方体，并通过着色器将立方体贴图投影到场景背景。
    
    4. **内存管理：**
       - 清理 OpenGL 资源，包括纹理、VBO 和 VAO。
    
    ---
    
    ### **主要成员函数**
    
    #### **构造函数**
    1. `Skybox(const std::vector<std::string>& paths)`
       - 接收六张图片路径，生成立方体贴图。
       - 配置 OpenGL 缓存，用于渲染天空盒。
    
    2. `Skybox(const std::string& panoramaPath)`
       - 接收一张全景图路径，将其转换为立方体贴图。
       - 通过帧缓冲对象（FBO）和渲染缓冲对象（RBO）完成全景图到立方体贴图的转换。
    
    #### **析构函数**
    - `~Skybox()`
       - 释放 OpenGL 资源（VAO、VBO、纹理）。
    
    #### **渲染函数**
    - `void Draw(Shader& shader, glm::mat4 model, glm::mat4 view, glm::mat4 projection)`
       - 使用提供的着色器和矩阵渲染天空盒。
       - 将观察矩阵的位移部分移除，以避免视角平移导致天空盒位置变化。
    
    #### **辅助函数**
    1. `unsigned int GenCubeMap(const std::vector<std::string>& facePaths)`
       - 从六张图片生成立方体贴图。
       - 设置纹理的过滤和环绕模式。
    
    2. `unsigned int GenCubeMapFromPanorama(const std::string& panoramaPath)`
       - 将全景图转换为立方体贴图。
       - 使用帧缓冲和专用着色器完成转换。
    
    3. `void renderCube()`
       - 渲染一个1x1的立方体，用于将立方体贴图投影到背景。
    
    ---
    
    ### **协作关系**
    1. **与`Shader`的协作：**
       - 使用着色器处理矩阵变换和采样立方体贴图。
       - 着色器需要支持`model`、`view`、`projection`矩阵以及`skybox`采样器。
    
    2. **与 OpenGL 的协作：**
       - 利用 OpenGL 管线完成顶点绘制和纹理映射。
       - 配置帧缓冲（FBO）和渲染缓冲（RBO）处理全景图。
    
    3. **与纹理工具库的协作：**
       - 使用`stb_image`加载纹理文件。
    
    ---
    
    ### **类在系统设计中的作用**
    1. **背景环境的渲染：**
       - 模拟远处的天空或环境，提高场景的沉浸感。
    
    2. **提升图形渲染质量：**
       - 提供高分辨率的背景贴图或动态环境反射（通过 CubeMap 反射）。
    
    3. **全景图支持：**
       - 将复杂的 HDR 全景图转换为立方体贴图，为全局光照和反射提供支持。
    
    4. **可扩展性：**
       - 支持用户切换不同的天空盒或动态加载全景图，实现多样化的场景效果。
    ```

- **捕获 Capture：**

  - CaptureManager

    ```
    #### **功能概述**
    `CaptureManager`类是一个用于捕获屏幕内容（截图或录屏）的辅助工具类，基于OpenGL的`glReadPixels`功能实现，同时支持生成PNG格式截图和使用`ffmpeg`进行实时录制的视频文件输出。
    
    ---
    
    ### **主要职责**
    1. **截图功能：**
       - 捕获当前屏幕内容并保存为PNG格式的图片文件。
    
    2. **录屏功能：**
       - 使用`ffmpeg`实时录制屏幕内容为MP4视频文件。
    
    3. **管理文件保存：**
       - 确保截图和录屏文件按编号命名并存储在指定目录中。
    
    4. **资源管理：**
       - 管理像素缓冲区的分配和释放，确保`ffmpeg`管道的正确打开与关闭。
    
    ---
    
    ### **主要成员函数**
    
    #### **截图功能**
    - `bool captureScreen(const std::string& basePath)`
      - 捕获屏幕像素数据，保存为PNG文件。生成文件名带编号。
    
    #### **录屏功能**
    1. `bool startRecording(const std::string& basePath, int fps)`
       - 初始化`ffmpeg`管道，开始录制视频。
    2. `void recordFrame()`
       - 将当前帧的屏幕像素写入`ffmpeg`管道。
    3. `void stopRecording()`
       - 停止录制，关闭`ffmpeg`管道。
    
    #### **内部工具**
    1. `bool initFfmpegPipe(const std::string& videoPath, int fps)`
       - 构造并执行`ffmpeg`命令，初始化管道。
    2. `void closeFfmpegPipe()`
       - 关闭`ffmpeg`管道。
    3. `void ensureCaptureFolderExists()`
       - 检查并确保截图与录屏文件夹存在。
    
    ---
    
    ### **协作关系**
    
    1. **与OpenGL的协作：**
       - 使用`glReadPixels`读取当前帧缓冲区的像素数据。
       - 配合OpenGL上下文，确保图像内容准确捕获。
    
    2. **与`ffmpeg`的协作：**
       - 构建`ffmpeg`命令管道，将录屏数据实时写入视频文件。
       - 管理`ffmpeg`管道的打开与关闭。
    
    3. **与`stb_image_write`库的协作：**
       - 使用`stb_image_write`库将捕获的像素数据保存为PNG文件。
    
    4. **与文件系统的协作：**
       - 使用`std::filesystem`确保输出文件夹的存在。
    
    ---
    
    ### **类在系统设计中的作用**
    
    1. **屏幕捕获模块：**
       - 提供了便捷的接口，支持开发者在运行时捕获场景内容（截图或录屏）。
       - 适用于实时渲染结果的存档和调试。
    
    2. **用户交互与输出：**
       - 在场景中记录关键帧或生成高质量的屏幕录像，适合用于演示和可视化。
    
    3. **跨平台工具链集成：**
       - 使用`ffmpeg`作为后台支持，兼容多种操作系统，提供高效的视频录制能力。
    ```

- **照明 Lighting：**

  - Light

    ```
    #### **功能概述**
    `Light`类是一个抽象基类，用于表示渲染系统中的通用光源。它提供了一个统一接口，支持三种具体的光源类型：
    1. **DirectionalLight（方向光）：** 用于模拟太阳光等平行光源。
    2. **PointLight（点光源）：** 用于模拟灯泡等点状光源。
    3. **SpotLight（聚光灯）：** 用于模拟手电筒等锥形光源。
    
    这些光源类共同为场景中的光照计算和阴影生成提供必要的数据和方法。
    
    ---
    
    ### **主要职责**
    
    #### **Light（基类）**
    1. 定义光源的基本接口，包括类型、位置、方向、颜色和强度的获取与设置。
    2. 提供投影矩阵和视图矩阵的接口，用于生成光源的投影和视图空间。
    
    #### **DirectionalLight**
    - 模拟无限远的平行光源，例如太阳光。
    - 提供正交投影矩阵，用于生成阴影贴图。
    - 通过方向向量定义光线的方向。
    
    #### **PointLight**
    - 模拟点状光源，例如灯泡。
    - 使用6个面向不同方向的投影矩阵（立方体贴图）实现全方向的阴影。
    - 通过位置定义光源的光照范围。
    
    #### **SpotLight**
    - 模拟锥形光源，例如手电筒。
    - 提供基于透视投影的视图和投影矩阵。
    - 通过位置、方向和截锥角度（cutoff）定义光照范围。
    
    ---
    
    ### **主要成员函数**
    
    #### **Light**
    - `getType()`: 获取光源类型。
    - `getProjectionMatrix()` 和 `getViewMatrix()`:
      - 生成光源的投影矩阵和视图矩阵，用于光照计算和阴影映射。
    - `getPosition()` 和 `getDirection()`:
      - 返回光源的位置和方向。
    - `getColor()` 和 `getIntensity()`:
      - 获取光源的颜色和强度。
    - `setPosition()`, `setDirection()`, `setColor()`, `setIntensity()`:
      - 设置光源属性（基类抛出异常，由子类实现具体逻辑）。
    
    #### **DirectionalLight**
    - `getProjectionMatrix()`: 返回正交投影矩阵。
    - `getViewMatrix()`: 根据光源方向返回视图矩阵。
    - `setDirection()`, `setColor()`, `setIntensity()`: 设置方向光的属性。
    
    #### **PointLight**
    - `getProjectionMatrix()`: 返回透视投影矩阵。
    - `getViewMatrices()`: 返回6个面（立方体贴图）的视图矩阵，用于全方向光影。
    - `setPosition()`, `setColor()`, `setIntensity()`: 设置点光源的属性。
    
    #### **SpotLight**
    - `getProjectionMatrix()`: 返回透视投影矩阵。
    - `getViewMatrix()`: 根据光源位置和方向返回视图矩阵。
    - `setPosition()`, `setDirection()`, `setColor()`, `setIntensity()`, `setCutoffAngle()`: 设置聚光灯的属性。
    
    ---
    
    ### **协作关系**
    
    1. **与渲染器的协作：**
       - 提供光源的投影矩阵、视图矩阵和颜色信息，用于计算场景光照和生成阴影贴图。
       - 方向光与正交投影协作，点光源与立方体贴图协作，聚光灯与透视投影协作。
    
    2. **与阴影管理器的协作：**
       - 阴影管理器使用光源的矩阵和范围信息生成阴影贴图。
    
    3. **与场景的协作：**
       - 场景通过添加光源对象来影响场景中的光照效果。
    
    ---
    
    ### **类在系统设计中的作用**
    
    1. **统一接口：**
       - `Light`基类为不同类型的光源提供统一接口，方便场景渲染器和阴影管理器与光源交互。
    
    2. **光照计算：**
       - 各具体光源类提供了不同的光照计算模型，适应多种渲染需求。
       - 通过视图矩阵和投影矩阵定义光源的投射范围。
    
    3. **扩展性：**
       - 新的光源类型可以通过继承`Light`类轻松扩展。
    
    4. **场景真实感：**
       - 不同类型的光源增强了场景渲染的多样性和真实感，例如太阳光、点光源和聚光灯分别适用于室外、室内和焦点照明。
    ```

  - LightManager

    ```
    #### **功能概述**
    `LightManager` 是光源系统的管理器，负责场景中所有光源的管理与渲染。它支持添加、移除、更新、序列化光源，并通过统一缓冲对象 (UBO) 将光源数据传递到着色器中。
    
    ---
    
    ### **主要职责**
    1. **光源管理：**
       - 管理场景中的所有光源，包括添加、删除、清空光源列表。
       - 支持多种光源类型（方向光、点光、聚光灯）。
    
    2. **光源数据同步：**
       - 使用统一缓冲对象 (UBO) 高效存储和传递光源数据给 GPU。
       - 支持在运行时动态更新光源的属性和数量。
    
    3. **与着色器交互：**
       - 绑定光源数据到着色器中的 Uniform 块，实现实时渲染。
    
    4. **数据持久化：**
       - 提供光源的序列化和反序列化功能，支持将场景光照配置保存为 JSON 或从 JSON 恢复。
    
    ---
    
    ### **主要成员函数**
    
    #### **光源管理**
    - `addLight(std::shared_ptr<Light> light)`：
      - 添加光源到管理器。
      - 如果超出最大光源数，则抛出异常。
    
    - `removeLight(int index)`：
      - 根据索引移除光源。
      - 提供边界检查，防止非法访问。
    
    - `getLight(int index)`：
      - 获取指定索引的光源对象。
    
    - `getLightCount()`：
      - 返回当前光源数量。
    
    - `clearLights()`：
      - 清空所有光源。
    
    #### **UBO 更新与绑定**
    - `updateUBO()`：
      - 将所有光源的属性数据（位置、方向、颜色、参数）更新到统一缓冲对象中。
      - 根据光源类型填充不同的数据结构。
    
    - `bindUBOToShader(const Shader& shader, unsigned int bindingPoint)`：
      - 将 UBO 绑定到着色器中的 Uniform 块，使光源数据能够在 GPU 中访问。
    
    #### **数据持久化**
    - `serialize()`：
      - 将光源列表转换为 JSON 格式，包括光源类型、位置、方向、颜色等属性。
    
    - `deserialize(const nlohmann::json& lightsJson)`：
      - 从 JSON 数据恢复光源配置，并重新构建光源列表。
    
    ---
    
    ### **协作关系**
    
    1. **与光源 (`Light` 类) 的关系：**
       - `LightManager` 使用多态设计管理不同类型的光源对象（`DirectionalLight`、`PointLight`、`SpotLight`）。
       - 提供统一接口与光源交互，例如获取位置、颜色、方向等。
    
    2. **与渲染器的关系：**
       - 渲染器通过调用 `bindUBOToShader` 将光源数据绑定到 GPU。
       - 着色器中通过 Uniform 块直接访问光源数据，减少 Uniform 调用的开销。
    
    3. **与场景的关系：**
       - 场景中所有的光源由 `LightManager` 统一管理和操作。
    
    4. **与持久化系统的关系：**
       - 使用 JSON 格式保存和加载光源配置，支持场景数据的跨平台传输与编辑。
    
    ---
    
    ### **类在系统设计中的作用**
    
    1. **统一管理：**
       - 将光源的管理逻辑集中在一个类中，方便扩展和维护。
       - 支持不同类型光源的混合使用。
    
    2. **性能优化：**
       - 使用 UBO 优化光源数据的传输效率，减少 CPU 到 GPU 的交互次数。
       - 避免逐个更新光源的繁琐操作，提高渲染性能。
    
    3. **数据持久化：**
       - 支持光源配置的保存与加载，为场景编辑器和动态场景切换提供便利。
    
    4. **扩展性：**
       - 可以通过继承 `Light` 类扩展新的光源类型，而无需修改 `LightManager` 的核心逻辑。
    ```

  - ShadowManager

    ```
    #### **功能概述**
    `ShadowManager` 是一个专门用于管理阴影生成与渲染的类。它为每个光源分配所需的资源（帧缓冲和阴影贴图），并提供了接口来生成和更新阴影贴图。`ShadowManager` 支持方向光、点光源和聚光灯的阴影渲染，能够动态调整分辨率并同步光源变化。
    
    ---
    
    ### **主要职责**
    
    1. **阴影资源管理：**
       - 为场景中的每个光源分配帧缓冲对象和纹理资源。
       - 管理点光源的立方体贴图、方向光和聚光灯的二维深度贴图。
    
    2. **阴影贴图生成：**
       - 使用不同的着色器生成对应光源类型的阴影贴图。
       - 支持实时渲染更新，保证动态阴影的实时性。
    
    3. **同步光源变化：**
       - 通过与光源列表同步，动态调整阴影资源的数量和类型。
    
    4. **分辨率控制：**
       - 提供接口动态调整阴影贴图的分辨率，以平衡性能和质量。
    
    5. **数据查询与获取：**
       - 提供接口获取指定光源的阴影贴图或光空间变换矩阵。
    
    ---
    
    ### **主要成员函数**
    
    #### **资源管理**
    - `setupShadowResources(ShadowData& data, int resolution, LightType type)`：
      - 根据光源类型（点光源、方向光、聚光灯）创建对应的帧缓冲和纹理资源。
    
    - `syncShadowDataWithLights(const std::vector<Light*>& lights)`：
      - 同步光源列表和阴影资源数量，动态创建或销毁多余的资源。
    
    - `updateShadowResolution(int newResolution)`：
      - 调整所有阴影贴图的分辨率，适应性能需求。
    
    #### **阴影生成**
    - `generateShadowMaps(const std::vector<Light*>& lights, Scene& scene, Shader& shadowShader, Shader& pointShadowShader)`：
      - 为每个光源生成阴影贴图。
      - 根据光源类型选择不同的着色器，并设置对应的光源参数。
    
    #### **辅助功能**
    - `getShadowTexture(int index)`：
      - 返回指定光源的阴影贴图纹理 ID，便于绑定到渲染管线。
    
    - `getLightSpaceMatrix(const std::vector<Light*>& lights, int index)`：
      - 返回光源的光空间变换矩阵（适用于方向光和聚光灯）。
    
    ---
    
    ### **协作关系**
    
    1. **与光源 (`Light`) 的关系：**
       - 通过光源类型（`LightType`）来决定创建的阴影资源种类（二维深度贴图或立方体贴图）。
       - 使用光源的投影和视图矩阵生成光空间变换。
    
    2. **与场景 (`Scene`) 的关系：**
       - 调用 `Scene::drawShadowMaps` 方法渲染场景到帧缓冲，生成阴影贴图。
    
    3. **与着色器 (`Shader`) 的关系：**
       - 为不同类型的光源选择合适的阴影着色器（例如平行光与点光的阴影生成逻辑不同）。
       - 通过设置 Uniform 数据向着色器传递光源信息。
    
    4. **与 OpenGL 资源的关系：**
       - 管理 OpenGL 的帧缓冲对象和纹理资源。
       - 使用 OpenGL 的状态管理（如 `glViewport` 和 `glCullFace`）优化阴影渲染。
    
    ---
    
    ### **类在系统设计中的作用**
    
    1. **阴影生成的核心组件：**
       - 将复杂的阴影生成逻辑封装在单一模块中，提供统一的接口。
       - 支持场景中多个光源的动态阴影渲染。
    
    2. **优化性能：**
       - 通过动态调整阴影分辨率和资源数量，适配不同硬件性能。
       - 使用帧缓冲和深度贴图分离阴影渲染和场景渲染。
    
    3. **增强渲染效果：**
       - 支持高质量阴影渲染，适应不同类型的光源（如点光源的立方体贴图）。
    
    4. **模块化与扩展性：**
       - 使用组合设计模式，通过 `ShadowResource` 和 `ShadowData` 封装资源，易于扩展新的光源类型或阴影算法。
    ```

  - Shader

    ```
    #### **功能概述**
    `Shader` 类是一个通用的着色器管理工具，用于加载、编译和管理 OpenGL 着色器程序。它提供了多种实用接口，用于设置着色器中的 uniform 变量。
    
    ---
    
    ### **主要职责**
    
    1. **着色器编译与链接：**
       - 从文件中加载顶点、片段和几何着色器代码。
       - 编译单个着色器，并链接为一个完整的着色器程序。
    
    2. **着色器程序的使用：**
       - 提供接口激活着色器程序（`use()`）。
    
    3. **Uniform 变量设置：**
       - 提供多种类型（布尔、整数、浮点、向量、矩阵）的 `uniform` 变量设置方法。
       - 支持通过名称定位和设置着色器中的 `uniform`。
    
    4. **错误检查与调试：**
       - 在着色器编译和链接时检测错误，并输出详细日志。
    
    ---
    
    ### **主要成员函数**
    
    #### **构造与析构**
    - `Shader(const char* vertexPath, const char* fragmentPath, const char* geometryPath = nullptr)`：
      - 从指定路径加载顶点、片段和（可选的）几何着色器代码，完成编译和链接。
    
    - `~Shader()`：
      - 默认析构函数，负责清理资源。
    
    #### **着色器使用**
    - `void use()`：
      - 激活着色器程序。
    
    #### **Uniform 设置**
    - `setBool(const std::string& name, bool value)`：
      - 设置布尔类型的 uniform 变量。
    
    - `setInt(const std::string& name, int value)`：
      - 设置整数类型的 uniform 变量。
    
    - `setFloat(const std::string& name, float value)`：
      - 设置浮点数类型的 uniform 变量。
    
    - `setVec2`, `setVec3`, `setVec4`：
      - 设置 2D/3D/4D 向量类型的 uniform 变量。
    
    - `setMat2`, `setMat3`, `setMat4`：
      - 设置 2x2, 3x3, 4x4 矩阵类型的 uniform 变量。
    
    #### **错误检查**
    - `checkCompileErrors(unsigned int shader, std::string type)`：
      - 检查着色器编译或链接时的错误，并输出详细日志。
    
    ---
    
    ### **协作关系**
    
    1. **与 OpenGL 的关系：**
       - 使用 OpenGL API（如 `glCreateShader`、`glCompileShader`、`glLinkProgram` 等）实现着色器的创建、编译和管理。
       - 管理 OpenGL 的着色器程序 ID。
    
    2. **与渲染流程的关系：**
       - 在渲染流程中提供一个便捷的接口，帮助用户快速切换和配置着色器。
       - 配合其他渲染模块（如 `Scene`, `GameObject`）传递数据到 GPU。
    
    3. **与文件系统的关系：**
       - 从外部文件中加载 GLSL 代码，支持用户自定义着色器逻辑。
    
    ---
    
    ### **类在系统设计中的作用**
    
    1. **着色器抽象层：**
       - 提供一个高层接口，将复杂的 OpenGL 着色器 API 封装为易于使用的类方法。
       - 屏蔽底层 API 细节，提高开发效率。
    
    2. **渲染模块的桥梁：**
       - 在渲染流程中，`Shader` 类是 CPU 和 GPU 数据交换的桥梁。
       - 提供了统一的接口来管理和操作 GPU 中的 `uniform` 变量。
    
    3. **代码复用与扩展：**
       - 通过支持多种着色器类型（顶点、片段、几何），满足不同渲染需求。
       - 支持任意数量和类型的 `uniform`，提高代码复用性。
    ```

- **逻辑 Logic：**

  - CollisionManager

    ```
    ### **类分析：`CollisionManager`**
    
    #### **功能概述**
    `CollisionManager` 是一个静态类，用于处理三维场景中物体之间的碰撞检测。它主要通过检查物体的轴对齐包围盒（Axis-Aligned Bounding Box, AABB）来判断是否发生碰撞。
    
    ---
    
    ### **主要职责**
    
    1. **AABB 碰撞检测：**
       - 使用简单的数学逻辑判断两个物体的包围盒是否相交。
    
    2. **场景中物体之间的碰撞检测：**
       - 遍历所有物体，检查它们之间是否发生碰撞，并输出碰撞结果。
    
    3. **与特定物体的碰撞检测：**
       - 检查一个包围盒是否与场景中的任何物体发生碰撞。
    
    4. **碰撞响应（扩展）：**
       - 为未来扩展更复杂的碰撞响应机制提供基础。
    
    ---
    
    ### **主要成员函数**
    
    #### **静态方法**
    
    1. **`checkCollision(const BoundingBox& a, const BoundingBox& b)`**
       - **功能：** 检查两个包围盒是否发生碰撞。
       - **逻辑：** 比较两个包围盒在每个轴上的最小值和最大值，判断是否重叠。
       - **返回值：** `true` 表示碰撞，`false` 表示没有碰撞。
    
    2. **`detectCollisions(const std::vector<std::shared_ptr<GameObject>>& objects)`**
       - **功能：** 检测场景中所有物体之间的碰撞。
       - **逻辑：** 使用嵌套循环，遍历所有物体的组合对，调用 `checkCollision` 检查是否发生碰撞。
       - **扩展：** 输出碰撞的物体名称。
    
    3. **`detectCollisions(const BoundingBox& a, std::vector<std::shared_ptr<GameObject>>& objects)`**
       - **功能：** 检查指定的包围盒是否与场景中的任意物体发生碰撞。
       - **逻辑：** 遍历场景中的物体，逐一调用 `checkCollision`。
       - **返回值：** `true` 表示发生碰撞，`false` 表示没有碰撞。
    
    ---
    
    ### **协作关系**
    
    1. **与 `BoundingBox` 的关系：**
       - `CollisionManager` 使用 `BoundingBox` 提供的边界信息（`min` 和 `max`）进行碰撞检测。
       - 依赖 `BoundingBox` 的几何信息进行计算。
    
    2. **与 `GameObject` 的关系：**
       - 调用 `GameObject` 的 `getBoundingBox` 和 `getName` 方法，获取包围盒和物体名称。
       - 适配 `GameObject` 的接口，以实现物体之间的碰撞检测。
    
    3. **与场景管理的关系：**
       - 遍历场景中的物体列表，协助场景管理器（如 `Scene`）实现物理交互的基础。
    
    ---
    
    ### **类在系统设计中的作用**
    
    1. **物理引擎的核心组件：**
       - `CollisionManager` 是游戏物理系统中的关键部分，用于检测物体之间的空间交互。
       - 提供了基础的碰撞检测能力，支持更复杂的物理模拟和响应（如弹跳、阻挡）。
    
    2. **简化开发流程：**
       - 将碰撞检测逻辑集中封装，减少重复代码。
       - 提供通用接口，方便其他模块调用。
    
    3. **性能优化的基础：**
       - 当前实现使用简单的两两遍历，适用于小规模场景。
       - 为未来的性能优化（如空间分区、四叉树或八叉树）提供了接口和框架。
    ```

- **着色器 Shader**

- **demo.cpp**

----





